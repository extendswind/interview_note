

《剑指offer》刷题

前面的题目貌似难度都不太大，主要是根据思路注意细节，后面重点掌握思路就不一题题撸代码了。

# 2 Singleton 设计模式

方案1，静态get函数，函数中判断对象指针是否为空，如果为空则创建，否则返回对象指针。（多线程会出问题）

方案2，对判断过程加锁。（会导致耗时）

方案3，双重判断 （在加锁之上再加一层判断，因此只在创建对象时有锁的耗时）。在java里重点考，因为涉及到volatile关键字和加锁。

方案4，静态成员在程序运行时初始化。（无法在使用时创建）

方案5，内部类成员。（由于内部类对象依赖外部类对象，因此会在外部类对象构建时初始化单例对象）最佳方案。

# [3查找重复数字]（_3FindRepeatNum.java)

> 找出数组中重复的数字。
>
> 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
>
> 示例 1：
>
> 输入：
> [2, 3, 1, 0, 2, 5, 3]
> 输出：2 或 3
>
> 限制：
>
> 2 <= n <= 100000
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof


思路多，但实现比较简单：

1. 排序
2. HashSet
3. 通过一个大数组，每次在数组上对应下表上做标记。（类似对一个大数组的hash）
4. 直接在原数组上做变换

前面三种实现都简单，排序的时间复杂度略长，另外两种典型的时间换空间。

在原数组可以改变的情况下可以考虑方法4，将所有的数依次交换到到数组对应下标的位置，发现下标处已经有对应数字时则为重复数字。

当题目改为长度为n+1的数组里，所有数都在[0, n-1]的范围内，则可以考虑统计中间数m分割出的两个区间[0,m] (m, n-1]中的数字数量，哪个区间的数字更大则哪个区间中包含重复的数（类似二分查找）。


# [4二维数组的查找](_4FindNumIn2DArray.java)

## 题目
> 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
>
> 示例:
>
> 现有矩阵 matrix 如下：
>
> [
>   [1,   4,  7, 11, 15],
>   [2,   5,  8, 12, 19],
>   [3,   6,  9, 16, 22],
>   [10, 13, 14, 17, 24],
>   [18, 21, 23, 26, 30]
> ]
>
> 给定 target = 5，返回 true。
>
> 给定 target = 20，返回 false。
>
> 限制：
>
> 0 <= n <= 1000
>
> 0 <= m <= 1000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof

## 解决方案

书中推荐的方法是从右上角（或左下角）开始逐行逐列遍历，当查找的数组比当前数字小时，向左移一列；比当前数字大时，下移一行，直到找到要找的数字。

时间复杂度O(m+n)

## 另一种解决方案

对于题目中m、n数字都比较小的情况，重点是解决问题，效率不太重要。

排序和二分查找联系紧密，通过第一行和最后一行的数字，就可以通过二分查找得到哪几列包含想要的结果。然后在这几列中可以进一步的二分查找。ba


# [5替换空格](_5ReplaceSpace.java)

## 题目

> 请实现一个函数，把字符串 s 中的每个空格替换成"%20"。
>
> 示例 1：
>
> 输入：s = "We are happy."
> 输出："We%20are%20happy."

链接：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof

## 思路

使用另外的数组基本没什么难度。直接在原数组上做替换，如果从前到后的顺序替换会使每次替换时后面的字符都需要移动，但从后向前就没这个问题。

主要编程思路：从后向前修改数组。

吐槽一下leetcode，java版代码传入的参数是String类型，这个没法改了...  不像牛客网传入的参数是StringBuffer


# [6从尾到头打印链表](_6PrintListFromTailToHead.java)

从尾到头打印链表，感觉这个没啥意思，没什么特别的思路：

1. 改变原链表变成从尾到头的顺序；
2. 插入一个栈（直接插入ArrayList然后反向访问也一样，知道长度还可以直接插入数组）
3. 递归（同上面的栈）

# [7重建二叉树]

## 题目

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

来源：牛客网(剑指offer系列)

## 思路

核心思路是通过前序遍历的顺序找到根节点，然后从中序遍历的中找到被根节点划分的两部分分别为左子树和右子树。

通过递归的形式不断的通过下面的步骤：

1. 前序第一个为当前树的根节点
2. 通过上面的根节点，在中序找到根节点的两边即为左右子树
3. 通过2中左右子树的长度在前序中找到左右子树对应的前序
4. 得到左右子树的前序和中序的数组，用上面的步骤递归计算左右子树


# [9通过两个栈实现一个队列](_9QueueImplementByTwoStack.java)

主要思路：

1. push函数将元素压入stack1
2. pop函数调用时判断stack2是否为空，如果为空则讲stack1中的元素pop并push到stack2中，如果不为空则从stack2中取元素。


# [10斐波拉契数列]

这个实现不复杂，就不上代码了。实现的重点在于直接 `return f(n-1) + f(n-2)` 这种递归的方式效率并不高，一方面在不断的递归过程中重复算了很多次数（如f(n-2)算了两次， f(n-3)算了3次），另一方面递归层数多且不是尾递归。

书中建议直接使用循环而非递归计算，但是递归可以考虑下面通过传多个参数实现的尾递归形式的计算。

```java  尾递归实现
public int F(int n,int a1,int a2)
{
    return n == 0 ? a1 : F(n - 1, a2, a1 + a2);
}
```

一个逻辑上的游戏题：一只青蛙一次可以跳上一个台阶或者两个台阶，问跳上n个台阶一共有多少种方法。

可以先考虑青蛙如果第一次跳1个台阶，则后面一共的方法数为n-1个台阶的方法数；如果第一次跳2个台阶，则后面的方法数为n-2。因此 f(n) = f(n-1) + f(n-2)。（这思维方式...）


# 11旋转数组的最小数字

## 题目

> 把一个数组最开始的若干个元素搬到数组的末尾，称为数组的旋转。输入一个递增的数组的一个旋转，输出旋转数组的最小元素。如{3,4,5,1,2}是{1,2,3,4,5}的一个旋转，输出最小元素1。

## 思路

最暴力的方式也只有O(n)的时间复杂度，而且是有序，所以优先考虑二分查找类似的思路。

旋转数组可以看做左右两个有序的数组，而且右边数组的所有数都小于坐标数组。因此对于其中的任意一个数，如果大于最左边的数，则为左数组的一部分；否则，则为右边数组的一部分。

因此，可以参考二分查找做下面的实现：

1. 使用两个指针（left, right)，指向首尾两个元素。
2. 二分查找中间的元素nums[mid]，如果>= nums[left]，则让left = mid；如果<= nums[right]，让right = mid。


特殊情况 1 1 1 0 1，也就是上面的nums[mid], nums[left], nums[right]相等时，无法判断中间元素在左边还是右边。此时只能放在上面的2中判断，如果出现则通过顺序查找。


# 12矩阵中的路径

## 题目

> 设计一个函数，判断一个矩阵中是否存在一条包含矩阵中所有元素的路径。路径可以从任意一格开始，每一步只能上下左右四方向移动一格，每一格只能经过一次。

## 思路

虽然这题叫做矩阵中的路径，但实质上就是走迷宫而已，用栈实现的经典回溯算法。

1. 定义一个bool类型同样大小的矩阵，作为经过路径的标记。
2. 两层for循环指定所有的元素作为起点，调用递归函数。
3. 递归函数路径长度达到矩阵大小返回true，四个方向中有一个为true则返回true，四个方向都返回false时为false。

有一个很好的写法

```java
boolean hasPath = false;
hasPath = hasPathCore(...) // left
	|| hasPathCore(...)  // right
	|| hasPathCore(...)  // up
	|| hasPathCore(...)  // down
```


# 13机器人的运动范围

## 题目

地面上有一个m x n的网格，一个机器人从（0，0）开始移动，每次向上下左右移动一格，但不能进入行列坐标数位之和大于k的网格。例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18，但是不能进入（35,38）。请问机器人最多能到达多少个格子。

## 思路

其实这题和上面差不多，只是把每次判断上下左右是否移动出了原矩阵的判断中加入了新的限制条件。


# [14剪绳子](_14CutRope.java)

## 题目

一根长度为n的绳子，剪成m段（m、n都为整数，且m>1），每根绳子的长度记为k[0]、k[1]...k[m-1]。请问 k[0] x k[1] x ... x k[m] 可能的最大乘积是多少。

首先这题的题目里的m段略有误导，m并非函数定义的输入。问题更好定义成将长度为n的绳子剪成若干段，求可能的最大乘积。

## 思路

一道典型的动态规划问题。首先可以任意取第i个位置剪断第一次，绳子会被分成两段，如果设原式的结果为f(n)，则f(n) = max( f(i) * f(n-i) )   当 i=1...n-1 （题目中m>1）。此处有个小坑，f(n)中i的范围为[1, n-1]，由于一段绳子可能存在不剪的情况，f(i)中下一个i的范围为[0, n-1]，但对于此题不影响计算结果。

对于每一段划分后的f(n)，都可以遍历i=[0, n-1]的情况，最后问题转变成求n=[0, n-1]时一系列f(n)的最大值。

动态规划的重点是f(n)与f(n-i)之间如果存在关系，如果已知f(n)在n较小时的值，即可逐步推断f(n)的值。

## 具体实现

本题有两种实现方式，一种通过递归的形式从f(n)计算至f(1)，另一种从f(1)直接循环计算至f(n)。

首先已知f(1) = 1, f(2) = 2, f(3) = 3, f(4) = 4, 在后面当n>=5时，不用考虑f(5) = f(5) * f(0)的问题，因为f(n-2)*f(2)都大于f(n)和f(n-1)*f(1)。

因此，自底向上的方法中，对于n=[4, n]中的每个值，遍历i=[2, n/2]，找到使f(i)*f(n-i)的最大值。其实和求斐波拉契数列差不多，只不过一个是f(n) = f(n-1) + f(n-2)，一个是f(n) = max( f(i) * f(n-i) )。

自顶向下的方式通过递归，主要是注意缓存f(n)的计算结果。

## 贪婪算法

这个没多大意思，这规律找起来似乎有点碰运气。

长度为3的段越多，结果越大。因此尽可能的分出长度为3的段。

## 动态规划的思路

1. 划分子结构。通常是将动态规划的问题划分成f(n) = f(n-i) + f(i)类似的拆分问题。
2. 子结构的结果可以复用。划分后实质上的求解和穷举类似，如f(n) = f(n-1) + f(i)，穷举i为[0, n)时的结果，直接计算会计算量很大，但是中间f(n-2), f(n-3)等计算了多次，结果可以复用。


# [15二进制中1的个数](_15Count1InBinary.java)

## 题目

输入一个整数，输出该数二进制表示中1的个数。

## 思路

对于数字n，对1按位与可以得到个位是否为0，向右移位可以得到下一个个位。

注意负数的情况，负数用普通的向右移位（>>）时，会在首位补1。需要用无符号移位，java中为>>>，c++中先转为无符号整数。

更好的方式是对1移位，然后和原数中的每一位按位与比较判断是否为1.

## 注意

java中对于负数的处理，二进制数以补码（反码 + 1）的方式处理，因此-1的二进制为32个1。


# 16数值的整数次方

求n的m次方。（m为整数）

主要的坑在于需要考虑m为0或负数、n为0等特殊情况。

在算n的m次方时，可以考虑用n^2k = (n^k)^2降低算法复杂度。

# 17打印从1到最大的n位数

当n较大时，需要自行实现一个类似BigInteger的机制存储更大的n位数。

主要思路为构建一个n大小的数组，存储n位数。

主要麻烦在于处理进位问题。

# 18删除链表的节点

## 题目1

给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。

## 思路

删除一个节点通常让上一个节点的指针指向下一个节点，但只给出了当前节点的指针。

主要思路为将下一个节点的内容复制到当前节点，然后删除下一个节点的指针。

还需要考虑一些特殊情况：

1. 删除的是尾节点；
2. 链表只有一个节点（既是尾又是头）

## 题目2

删除链表中重复的元素

主要的坑：

head节点可能被删除，因此需要改变head指针的位置，因此需要传入head指针的地址  ListNode **pHead

# 19正则表达式匹配

'.'表示任意一个字符，'*'表示前面的字符出现0次或者任意次，如"aaa"和"a.a"匹配。

主要用递归的形式，逐个匹配，如果匹配失败则退回另外的匹配方式。

又用到了  isMatch = fun(...) || fun(...) || fun(...)


# 20表示数值的字符串

## 题目

判断字符串是否正确的表示数字，如"+100", "5e2", "-123", "-1E-16"等表示正确，"1.1.1", "2e"等表示错误。

## 思路

这题主要是找规律，没有使用特别好的方案。题解中以连续整数为单位，首先扫描前面的整数，然后判断是否出现小数点等字符。


# 21调整数组顺序，使奇数位于偶数前面

题目如上

一个典型的双指针解法。一个指针从最左边找偶数，一个指针从最右边找奇数，每次找到时两个数互换。直到两个指针相遇。

题目很容易扩展到使正数在负数的左边等其它情况，如果需要考虑可扩展性，可以考虑用指向函数的指针。

# 22单向链表的倒数第k个节点

题目如上

最简单的方式直接第一次遍历得到链表中节点的个数，然后从前向后遍历。

更高效的方式是通过两个指针，第一个指针比第二个指针早走k个节点，第一个指针到终点时第二个指针即为倒数第k个节点。

第二种方式重点在于考虑一系列的特殊情况，如倒数第k个节点不存在等。


# 23链表中环的入口节点

当链表中存在环时，如何找到环的入口节点

## 思路

判断环的存在很容易，用两个指针，一个一次一步，一个一次两步，看两个指针是否相交。从相交的节点处继续向前走，通过判断回到相交节点的步数可以判断环的大小。

此时判断出口可以让一个指针先移动环的大小步，然后两个指针以同样的速度运动（两个指针的间隔为环的大小）。这一情况下，两个指针相遇的节点即为入口节点。

# 24反转链表

没有很特别的思路，主要是注意几种特殊情况的测试，三个指针从头向尾移动。

这个面试出现的频率比较高，主要思路是让两个指针移动，在向后移动一个节点时，用第三个指针（临时指针）记录一下第二个指针next的位置，第二个指针的next指向第一个指针，第一二两个指针向后移动一步。

```java
public class Solution {
    public ListNode ReverseList(ListNode head) {
        ListNode l1 = head;
        if(l1 == null){
            return null;
        }
        ListNode l2 = l1.next;
        l1.next = null;
        if(l2 == null){
            return head;
        }
        ListNode l3;
        while(l2 != null){
            l3 = l2.next;
            l2.next = l1;
            l1 = l2;
            l2 = l3;
        }
        return l1;
    }
}
```

# 25合并两个递增的链表

使结果链表仍然递增。

也没什么特别的方法。

# 26树的子结构

输入两颗二叉树A和B，判断B是否为A的子结构。

## 思路

前序遍历二叉树A，判断节点值是否与B的根节点相等，如果相等则比较其它节点，否则向后遍历。


# 27二叉树的镜像

输入一颗二叉树，返回二叉树的镜像。（左右子节点都交换位置）

## 思路

同上一题26，还是前序遍历加节点处理，在前序遍历中交换两个子树的位置。


# 28对称的二叉树

判断二叉树是否对称，即二叉树与其镜像（镜像同题26）

## 思路

同样前序遍历，判断左右子树是否相等。


# 29顺时针打印矩阵

由外向里打印矩阵。每次打印一圈。

## 思路

考虑每次打印一圈，因此可以考虑使用函数递归向里打印。

主要考虑打印的过程中的特殊情况，如内部只有一行或者一列。


# 30包含min函数的栈

定义一个新的栈数据结构，使min、push、pop函数的时间复杂度都是O(1)

## 思路

使用辅助栈记录最小值。重点在于辅助栈只记录当前栈pop时需要弹出的最小值。如栈顺序为2,3,4,1,5，则辅助stack的顺序为2,2,2,1,1。这种情况下可以得到当前的最小值。

至于实现，主要就是在push时同时向辅助栈push此时的最小值，pop时同时pop辅助栈。


# 31栈的压入、弹出队列

输入两个整数数组，一个为栈的压入顺序，判断另一个是否为弹出顺序。

## 思路

按入栈顺序压入一个栈，如果出现出栈数组中的第一个数，则将该数弹出栈。一直压入弹出，判断是否栈中的元素都压入。


# 32



