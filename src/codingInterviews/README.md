

《剑指offer》刷题

# [3查找重复数字]（_3FindRepeatNum.java)

> 找出数组中重复的数字。
>
> 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
>
> 示例 1：
>
> 输入：
> [2, 3, 1, 0, 2, 5, 3]
> 输出：2 或 3
>
> 限制：
>
> 2 <= n <= 100000
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof


思路多，但实现比较简单：

1. 排序
2. HashSet
3. 通过一个大数组，每次在数组上对应下表上做标记。（类似对一个大数组的hash）
4. 直接在原数组上做变换

前面三种实现都简单，排序的时间复杂度略长，另外两种典型的时间换空间。

在原数组可以改变的情况下可以考虑方法4，将所有的数依次交换到到数组对应下标的位置，发现下标处已经有对应数字时则为重复数字。

当题目改为长度为n+1的数组里，所有数都在[0, n-1]的范围内，则可以考虑统计中间数m分割出的两个区间[0,m] (m, n-1]中的数字数量，哪个区间的数字更大则哪个区间中包含重复的数（类似二分查找）。


# [4二维数组的查找](_4FindNumIn2DArray.java)

## 题目
> 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
>
> 示例:
>
> 现有矩阵 matrix 如下：
>
> [
>   [1,   4,  7, 11, 15],
>   [2,   5,  8, 12, 19],
>   [3,   6,  9, 16, 22],
>   [10, 13, 14, 17, 24],
>   [18, 21, 23, 26, 30]
> ]
>
> 给定 target = 5，返回 true。
>
> 给定 target = 20，返回 false。
>
> 限制：
>
> 0 <= n <= 1000
>
> 0 <= m <= 1000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof

## 解决方案

书中推荐的方法是从右上角（或左下角）开始逐行逐列遍历，当查找的数组比当前数字小时，向左移一列；比当前数字大时，下移一行，直到找到要找的数字。

时间复杂度O(m+n)

## 另一种解决方案

对于题目中m、n数字都比较小的情况，重点是解决问题，效率不太重要。

排序和二分查找联系紧密，通过第一行和最后一行的数字，就可以通过二分查找得到哪几列包含想要的结果。然后在这几列中可以进一步的二分查找。ba


# [5替换空格](_5ReplaceSpace.java)

## 题目

> 请实现一个函数，把字符串 s 中的每个空格替换成"%20"。
>
> 示例 1：
>
> 输入：s = "We are happy."
> 输出："We%20are%20happy."

链接：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof

## 思路

使用另外的数组基本没什么难度。直接在原数组上做替换，如果从前到后的顺序替换会使每次替换时后面的字符都需要移动，但从后向前就没这个问题。

主要编程思路：从后向前修改数组。

吐槽一下leetcode，java版代码传入的参数是String类型，这个没法改了...  不像牛客网传入的参数是StringBuffer


# [6从尾到头打印链表](_6PrintListFromTailToHead.java)

从尾到头打印链表，感觉这个没啥意思，没什么特别的思路：

1. 改变原链表变成从尾到头的顺序；
2. 插入一个栈（直接插入ArrayList然后反向访问也一样，知道长度还可以直接插入数组）
3. 递归（同上面的栈）

# [7重建二叉树]

## 题目

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

来源：牛客网(剑指offer系列)

## 思路

核心思路是通过前序遍历的顺序找到根节点，然后从中序遍历的中找到被根节点划分的两部分分别为左子树和右子树。

通过递归的形式不断的通过下面的步骤：

1. 前序第一个为当前树的根节点
2. 通过上面的根节点，在中序找到根节点的两边即为左右子树
3. 通过2中左右子树的长度在前序中找到左右子树对应的前序
4. 得到左右子树的前序和中序的数组，用上面的步骤递归计算左右子树


# [9通过两个栈实现一个队列](_9QueueImplementByTwoStack.java)

主要思路：

1. push函数将元素压入stack1
2. pop函数调用时判断stack2是否为空，如果为空则讲stack1中的元素pop并push到stack2中，如果不为空则从stack2中取元素。


# [10斐波拉契数列]

这个实现不复杂，就不上代码了。实现的重点在于直接 `return f(n-1) + f(n-2)` 这种递归的方式效率并不高，一方面在不断的递归过程中重复算了很多次数（如f(n-2)算了两次， f(n-3)算了3次），另一方面递归层数多且不是尾递归。

书中建议直接使用循环而非递归计算，但是递归可以考虑下面通过传多个参数实现的尾递归形式的计算。

```java  尾递归实现
public int F(int n,int a1,int a2)
{
    return n == 0 ? a1 : F(n - 1, a2, a1 + a2);
}
```

一个逻辑上的游戏题：一只青蛙一次可以跳上一个台阶或者两个台阶，问跳上n个台阶一共有多少种方法。

可以先考虑青蛙如果第一次跳1个台阶，则后面一共的方法数为n-1个台阶的方法数；如果第一次跳2个台阶，则后面的方法数为n-2。因此 f(n) = f(n-1) + f(n-2)。（这思维方式...）

# []
