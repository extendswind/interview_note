

《剑指offer》刷题

前面的题目貌似难度都不太大，主要是根据思路注意细节，后面重点掌握思路就不一题题撸代码了。

# [3查找重复数字]（_3FindRepeatNum.java)

> 找出数组中重复的数字。
>
> 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
>
> 示例 1：
>
> 输入：
> [2, 3, 1, 0, 2, 5, 3]
> 输出：2 或 3
>
> 限制：
>
> 2 <= n <= 100000
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof


思路多，但实现比较简单：

1. 排序
2. HashSet
3. 通过一个大数组，每次在数组上对应下表上做标记。（类似对一个大数组的hash）
4. 直接在原数组上做变换

前面三种实现都简单，排序的时间复杂度略长，另外两种典型的时间换空间。

在原数组可以改变的情况下可以考虑方法4，将所有的数依次交换到到数组对应下标的位置，发现下标处已经有对应数字时则为重复数字。

当题目改为长度为n+1的数组里，所有数都在[0, n-1]的范围内，则可以考虑统计中间数m分割出的两个区间[0,m] (m, n-1]中的数字数量，哪个区间的数字更大则哪个区间中包含重复的数（类似二分查找）。


# [4二维数组的查找](_4FindNumIn2DArray.java)

## 题目
> 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
>
> 示例:
>
> 现有矩阵 matrix 如下：
>
> [
>   [1,   4,  7, 11, 15],
>   [2,   5,  8, 12, 19],
>   [3,   6,  9, 16, 22],
>   [10, 13, 14, 17, 24],
>   [18, 21, 23, 26, 30]
> ]
>
> 给定 target = 5，返回 true。
>
> 给定 target = 20，返回 false。
>
> 限制：
>
> 0 <= n <= 1000
>
> 0 <= m <= 1000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof

## 解决方案

书中推荐的方法是从右上角（或左下角）开始逐行逐列遍历，当查找的数组比当前数字小时，向左移一列；比当前数字大时，下移一行，直到找到要找的数字。

时间复杂度O(m+n)

## 另一种解决方案

对于题目中m、n数字都比较小的情况，重点是解决问题，效率不太重要。

排序和二分查找联系紧密，通过第一行和最后一行的数字，就可以通过二分查找得到哪几列包含想要的结果。然后在这几列中可以进一步的二分查找。ba


# [5替换空格](_5ReplaceSpace.java)

## 题目

> 请实现一个函数，把字符串 s 中的每个空格替换成"%20"。
>
> 示例 1：
>
> 输入：s = "We are happy."
> 输出："We%20are%20happy."

链接：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof

## 思路

使用另外的数组基本没什么难度。直接在原数组上做替换，如果从前到后的顺序替换会使每次替换时后面的字符都需要移动，但从后向前就没这个问题。

主要编程思路：从后向前修改数组。

吐槽一下leetcode，java版代码传入的参数是String类型，这个没法改了...  不像牛客网传入的参数是StringBuffer


# [6从尾到头打印链表](_6PrintListFromTailToHead.java)

从尾到头打印链表，感觉这个没啥意思，没什么特别的思路：

1. 改变原链表变成从尾到头的顺序；
2. 插入一个栈（直接插入ArrayList然后反向访问也一样，知道长度还可以直接插入数组）
3. 递归（同上面的栈）

# [7重建二叉树]

## 题目

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

来源：牛客网(剑指offer系列)

## 思路

核心思路是通过前序遍历的顺序找到根节点，然后从中序遍历的中找到被根节点划分的两部分分别为左子树和右子树。

通过递归的形式不断的通过下面的步骤：

1. 前序第一个为当前树的根节点
2. 通过上面的根节点，在中序找到根节点的两边即为左右子树
3. 通过2中左右子树的长度在前序中找到左右子树对应的前序
4. 得到左右子树的前序和中序的数组，用上面的步骤递归计算左右子树


# [9通过两个栈实现一个队列](_9QueueImplementByTwoStack.java)

主要思路：

1. push函数将元素压入stack1
2. pop函数调用时判断stack2是否为空，如果为空则讲stack1中的元素pop并push到stack2中，如果不为空则从stack2中取元素。


# [10斐波拉契数列]

这个实现不复杂，就不上代码了。实现的重点在于直接 `return f(n-1) + f(n-2)` 这种递归的方式效率并不高，一方面在不断的递归过程中重复算了很多次数（如f(n-2)算了两次， f(n-3)算了3次），另一方面递归层数多且不是尾递归。

书中建议直接使用循环而非递归计算，但是递归可以考虑下面通过传多个参数实现的尾递归形式的计算。

```java  尾递归实现
public int F(int n,int a1,int a2)
{
    return n == 0 ? a1 : F(n - 1, a2, a1 + a2);
}
```

一个逻辑上的游戏题：一只青蛙一次可以跳上一个台阶或者两个台阶，问跳上n个台阶一共有多少种方法。

可以先考虑青蛙如果第一次跳1个台阶，则后面一共的方法数为n-1个台阶的方法数；如果第一次跳2个台阶，则后面的方法数为n-2。因此 f(n) = f(n-1) + f(n-2)。（这思维方式...）


# 11旋转数组的最小数字

## 题目

> 把一个数组最开始的若干个元素搬到数组的末尾，称为数组的旋转。输入一个递增的数组的一个旋转，输出旋转数组的最小元素。如{3,4,5,1,2}是{1,2,3,4,5}的一个旋转，输出最小元素1。

## 思路

最暴力的方式也只有O(n)的时间复杂度，而且是有序，所以优先考虑二分查找类似的思路。

旋转数组可以看做左右两个有序的数组，而且右边数组的所有数都小于坐标数组。因此对于其中的任意一个数，如果大于最左边的数，则为左数组的一部分；否则，则为右边数组的一部分。

因此，可以参考二分查找做下面的实现：

1. 使用两个指针（left, right)，指向首尾两个元素。
2. 二分查找中间的元素nums[mid]，如果>= nums[left]，则让left = mid；如果<= nums[right]，让right = mid。


特殊情况 1 1 1 0 1，也就是上面的nums[mid], nums[left], nums[right]相等时，无法判断中间元素在左边还是右边。此时只能放在上面的2中判断，如果出现则通过顺序查找。


# 12矩阵中的路径

## 题目

> 设计一个函数，判断一个矩阵中是否存在一条包含矩阵中所有元素的路径。路径可以从任意一格开始，每一步只能上下左右四方向移动一格，每一格只能经过一次。

## 思路

虽然这题叫做矩阵中的路径，但实质上就是走迷宫而已，用栈实现的经典回溯算法。

1. 定义一个bool类型同样大小的矩阵，作为经过路径的标记。
2. 两层for循环指定所有的元素作为起点，调用递归函数。
3. 递归函数路径长度达到矩阵大小返回true，四个方向中有一个为true则返回true，四个方向都返回false时为false。

有一个很好的写法

```java
boolean hasPath = false;
hasPath = hasPathCore(...) // left
	|| hasPathCore(...)  // right
	|| hasPathCore(...)  // up
	|| hasPathCore(...)  // down
```


# 13机器人的运动范围

## 题目

地面上有一个m x n的网格，一个机器人从（0，0）开始移动，每次向上下左右移动一格，但不能进入行列坐标数位之和大于k的网格。例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18，但是不能进入（35,38）。请问机器人最多能到达多少个格子。

## 思路

其实这题和上面差不多，只是把每次判断上下左右是否移动出了原矩阵的判断中加入了新的限制条件。


# [14剪绳子](_14CutRope.java)

## 题目

一根长度为n的绳子，剪成m段（m、n都为整数，且m>1），每根绳子的长度记为k[0]、k[1]...k[m-1]。请问 k[0] x k[1] x ... x k[m] 可能的最大乘积是多少。

首先这题的题目里的m段略有误导，m并非函数定义的输入。问题更好定义成将长度为n的绳子剪成若干段，求可能的最大乘积。

## 思路

一道典型的动态规划问题。首先可以任意取第i个位置剪断第一次，绳子会被分成两段，如果设原式的结果为f(n)，则f(n) = max( f(i) * f(n-i) )   当 i=1...n-1 （题目中m>1）。此处有个小坑，f(n)中i的范围为[1, n-1]，由于一段绳子可能存在不剪的情况，f(i)中下一个i的范围为[0, n-1]，但对于此题不影响计算结果。

对于每一段划分后的f(n)，都可以遍历i=[0, n-1]的情况，最后问题转变成求n=[0, n-1]时一系列f(n)的最大值。

动态规划的重点是f(n)与f(n-i)之间如果存在关系，如果已知f(n)在n较小时的值，即可逐步推断f(n)的值。

## 具体实现

本题有两种实现方式，一种通过递归的形式从f(n)计算至f(1)，另一种从f(1)直接循环计算至f(n)。

首先已知f(1) = 1, f(2) = 2, f(3) = 3, f(4) = 4, 在后面当n>=5时，不用考虑f(5) = f(5) * f(0)的问题，因为f(n-2)*f(2)都大于f(n)和f(n-1)*f(1)。

因此，自底向上的方法中，对于n=[4, n]中的每个值，遍历i=[2, n/2]，找到使f(i)*f(n-i)的最大值。其实和求斐波拉契数列差不多，只不过一个是f(n) = f(n-1) + f(n-2)，一个是f(n) = max( f(i) * f(n-i) )。

自顶向下的方式通过递归，主要是注意缓存f(n)的计算结果。

## 贪婪算法

这个没多大意思，这规律找起来似乎有点碰运气。

长度为3的段越多，结果越大。因此尽可能的分出长度为3的段。


# 15二进制中1的个数

## 题目

输入一个整数，输出该数二进制表示中1的个数。

## 方案一  整数右移判断个位


