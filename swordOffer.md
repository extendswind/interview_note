
# Singleton 设计模式

方案1，静态get函数，函数中判断对象指针是否为空，如果为空则创建，否则返回对象指针。（多线程会出问题）

方案2，对判断过程加锁。（会导致耗时）

方案3，双重判断 （在加锁之上再加一层判断，因此只在创建对象时有锁的耗时）。

方案4，静态成员在程序运行时初始化。（无法在使用时创建）

方案5，内部类成员。（由于内部类对象依赖外部类对象，因此会在外部类对象构建时初始化单例对象）最佳方案。


# 数组中找重复的元素

方案1，排序 n log(n) 

方案2， hash表  空间复杂度O(n)，时间复杂度O(n)


当数组中的元素都不大时，可以考虑：

方案3，交换数组中的位置。将每个数和数字对应下标处的数的位置交换。

方案4，构建一个新的数组（bit型），每次将数组中的数对应下标处做标记。（和桶排序的性质差不多）


当题目要求只找出一个重复的数时（n+1长度的数组，数字范围为[1,n]）：

方案5（不修改原数组，也不用O(n)级别的辅助数组），通过二分查找的形式，每次统计(0,n/2] [n/2, n]两个范围的数字数量，大的那个包含重复的数。



